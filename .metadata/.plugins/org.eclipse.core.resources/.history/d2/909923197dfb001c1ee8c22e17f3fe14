#include "file_names.h"
#include "types.h"
#include "utils.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// TODO: migliorare i messaggi all' utente (es: "inserisci questo ...")
// TODO: aggiungere i controlli di inserimento int, string, ecc. ad es
//       creando delle funzioni in utils.c come inputInt(), inputString(), ...
//       che gestiscono i vari casi

// RESTITUISCE L'UNITA' DI MISURA(stringa) CORRISPONDENTE ALL'UNITA' DI MISURA
// PASSATA
char *returnUnita(unita_misura unita) {
  char *s = (char *)calloc(
      10,
      sizeof(
          char)); // alloca dinamicamente la memoria per contenere 10 caratteri

  // assegna a s l'unità di misura corrispondente
  if (unita == N_UNIT)
    strcpy(s, "");
  else {
    if (unita == PESO_GR)
      strcpy(s, "g");
    else {
      if (unita == PESO_KG)
        strcpy(s, "kg");
      else {
        if (unita == PESO_ML)
          strcpy(s, "ml");
        else {
          if (unita == PESO_L)
            strcpy(s, "lt");
          else
            strcpy(s, "ERROR");
        }
      }
    }
  }

  return s;
}

// RESTITUISCE L'UNITA' DI MISURA(unita_misura) CORRISPONDENTE ALLA STRINGA
// PASSATA
unita_misura getUnita(char *str) {
  unita_misura unita;

  if (strEqual(str, "G")) {
    unita = PESO_GR;
  } else if (strEqual(str, "KG")) {
    unita = PESO_KG;
  } else if (strEqual(str, "ML")) {
    unita = PESO_ML;
  } else if (strEqual(str, "L")) {
    unita = PESO_L;
  } else if (strEqual(str, "N")) {
    unita = N_UNIT;
  } else {
    unita = NONE_UNIT;
  }
  return unita;
}




// TODO: aggiungere ricerca su sottostringa (?? e forse cercavi ... ??)
/*dato che dobbiamo visualizzare gli alimenti in ordine alfabetico possiamo
 * pensare di ordinare direttamente il file_alimenti e usare qui la ricerca
 * binaria*/

int ricerca_alimento(char *nome, t_alimento *alimento, FILE *file_alimenti) {
  int flag_alimento_trovato = 0;
  t_alimento alimento_corrente;

  strToUpper(nome);

  // cerca nel file alimenti e ritorna 1/0 se lo trova e lo setta in *alimento
  rewind(file_alimenti);
  fread(&alimento_corrente, sizeof(t_alimento), 1, file_alimenti);

  while (!feof(file_alimenti) && (flag_alimento_trovato == 0)) {
    if (strcmp(alimento_corrente.nome, nome) == 0) {
      flag_alimento_trovato = 1;
      *alimento = alimento_corrente;
      fseek(file_alimenti, -1 * sizeof(t_alimento),
            SEEK_CUR); // sposta di uno indietro
    } else {
      fread(&alimento_corrente, sizeof(t_alimento), 1, file_alimenti);
    }
  }
  return flag_alimento_trovato;
}



void ordinaFileAlimenti_AZ(char *file_name) {

  FILE *file;

  t_alimento j_alimento;
  t_alimento i_alimento;
  t_alimento min_alimento;

  t_alimento al;

  int i = 0;
  int i_min;
  int j;

  if (apriFile(&file, file_name, "rb+")) {
    rewind(file);

    //-----
    fread(&i_alimento, sizeof(t_alimento), 1, file);
    min_alimento = i_alimento;
    //-----

    while (!feof(file)) {
      // TODO: levare//printf("->%s  i:%d\n", i_alimento.nome, i);

      fread(&j_alimento, sizeof(t_alimento), 1, file);
      j = i + 1;
      min_alimento = i_alimento;
      i_min = i;

      while (!feof(file)) {

        // TODO: levare//printf("\t%s  j:%d\n", j_alimento.nome, j);

        if (strMin(j_alimento.nome, min_alimento.nome)) {
          min_alimento = j_alimento;
          i_min = j;
        }

        fread(&j_alimento, sizeof(t_alimento), 1, file);
        j++;
      }

      // TODO: levare//printf("\tmin_al:%s  i_min:%d\n", min_alimento.nome,
      // i_min);

      // file[i_min] = i_alimento
      fseek(file, i_min * sizeof(t_alimento), SEEK_SET);
      fwrite(&i_alimento, sizeof(t_alimento), 1, file);

      // file[i] = min_alimento
      fseek(file, (i) * sizeof(t_alimento), SEEK_SET);
      fwrite(&min_alimento, sizeof(t_alimento), 1, file);

      //----

      i++;
      fseek(file, i * sizeof(t_alimento), SEEK_SET);
      fread(&i_alimento, sizeof(t_alimento), 1, file);
      min_alimento = i_alimento;
      //-----
    }

    fclose(file);
  }
}

void print_alimento(t_alimento alimento) {
  printf("\t%s:", alimento.nome);
  // se g/ml>=1000 si stampa convertito in kg/lt
  if ((alimento.unita == PESO_GR) || (alimento.unita == PESO_ML)) {
    if (alimento.quantita >= 1000) {
      printf("  %.3f %s\n", (float)(((float)alimento.quantita) / 1000.0),
             returnUnita(alimento.unita + 1));
    } else
      printf("  %d %s\n", alimento.quantita, returnUnita(alimento.unita));
  } else
    printf("  %d %s\n", alimento.quantita, returnUnita(alimento.unita));
}

void print_alimenti() {
  t_alimento alimento_corrente;
  FILE *file_alimenti;

  if (apriFile(&file_alimenti, FILENAME_ALIMENTI, "rb+")) {
    rewind(file_alimenti);
    fread(&alimento_corrente, sizeof(t_alimento), 1, file_alimenti);

    while (!feof(file_alimenti)) {
      if (strcmp(alimento_corrente.nome, "") != 0) {
        print_alimento(alimento_corrente);
      }
      fread(&alimento_corrente, sizeof(t_alimento), 1, file_alimenti);
    }

    fclose(file_alimenti);
  }
}

// TODO: chiedere all utente di modificare l'alimento e modificarlo
void modifica_alimenti() {
  int input;
  char str[50];
  t_alimento alimento;
  FILE *file_alimenti; // frigo

  do {

    printf("Inserisci il nome dell'alimento da modificare/rimuovere >> ");
    scanf("%s", str);

    if (apriFile(&file_alimenti, FILENAME_ALIMENTI, "r+")) {

      if (ricerca_alimento(str, &alimento, file_alimenti)) {

        print_alimento(alimento);
        puts("[1] elimina alimento");
        puts("[2] modifica alimento");
        scanf("%d", &input);

        // elimina alimento
        if (input == 1) {
          strcpy(alimento.nome, "");
        }

        // modifica alimento
        if (input == 2) {
          // TODO: chiedere qui all utente cosa e di quanto modificare
          alimento.quantita += 100;
        }

        fwrite(&alimento, sizeof(t_alimento), 1, file_alimenti);

      } else {
        puts("alimento non trovato");
      }

      fclose(file_alimenti);
    }

    print_alimenti();

    printf("Modificare/Eliminare un altro alimento? [si:1, no:0] >> ");
    scanf("%d", &input);

  } while (input == 1);
}



//MODIFICARE CON INPUTALIMENTO NUOVO
/*
t_alimento input_alimento() {
  t_alimento alimento;
  char str[20];
  float quantita;
  int flag_errore = 0; // ricordarsi di mettere flag_errore=0;

  //---NOME---
  do {
    printf("\tnome >> ");
    scanf("%s", alimento.nome);

    flag_errore = checkLenght(alimento.nome, 20); // controllo sulla lunghezza

    if (flag_errore) { // se è avvenuto un errore
      printf("ERRORE! Il nome è più lungo della lunghezza massima "
             "consentita (L_MAX=20)\n");
    }

  } while (flag_errore);

  strToUpper(alimento.nome); // alimento.nome convertito in maiuscolo

  //---UNITA DI MISURA---
  do {
    printf("\tunita di misura >> ");
    scanf("%s", str);
    strToUpper(str);

    alimento.unita = getUnita(str);
  } while (alimento.unita ==
           NONE_UNIT); // controllo sull' unità di misura inserita

  //---QUANTITA---
  do {
    printf("\tquantita >> ");
    scanf("%s", str);

    flag_errore = isNotNum(
        str); // controlla che la stringa inserita sia composta da numeri
    if (!flag_errore) {

      quantita = (float)atof(str); // converte la stringa in un numero

      flag_errore = checkQuantita(
          quantita); // controlla che la quantità sia maggiore o uguale a 0
      if (!flag_errore) {

        if ((alimento.unita == PESO_KG) ||
            (alimento.unita == PESO_L)) { // se kg/lt si convertono in g/ml
          alimento.quantita = (int)(quantita * 1000);
          alimento.unita = alimento.unita - 1;
        } else {
          // Ci troviamo nei casi in cui alimento.unita=g/ml/n_elementii
          flag_errore = checkFloat(quantita);

          if (!flag_errore)
            alimento.quantita = (int)quantita;
        }
      }
    }

  } while (flag_errore);

  //---DISPENSA---
  alimento.dispensa = 0;

  return alimento;
}
*/
