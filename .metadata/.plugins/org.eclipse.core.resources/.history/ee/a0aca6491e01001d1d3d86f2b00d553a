/**
 * @def GESTIONE_RICETTE_H_
 * @brief contiene i sottoprogrammi che operano sul file ricette e cronologia ricette, e la relativa interazione con l'utente
 */

#ifndef GESTIONE_RICETTE_H_
#define GESTIONE_RICETTE_H_

#include "types.h"
#include <stdio.h>

/**
 * @fn void ordinaFileRicette_AZ(char*)
 * @brief ordina file_name di ricette in ordine alfabetico
 * @param file_name
 */
void ordinaFileRicette_AZ(char *file_name);


/**
 * @fn int ricerca_ricetta_binaria(char*, t_ricetta*, FILE*)
 * @brief ricerca una ricetta tramite il nome in file_ricette
 * @warning  usa la ricerca binaria quindi necessita che file_ricette sia ordinato!
 * @param nome
 * @param ricetta con valore della ricetta se trovata
 * @param file_ricette
 * @return 0 se non è stata trovata la ricetta
 *         1 se è stata trovata e viene memorizzata in *ricetta
 */
int ricerca_ricetta_binaria (char *nome, t_ricetta *ricetta, FILE *file_ricette);


/**
 * @fn void ricerca_ricettaSottstr(char*, t_ricetta[], int*, FILE*)
 * @brief cerca e restituisce tutte le ricette che contengono *nome per sottostringa nel loro nome
 * @param nome : sottostringa da cercare
 * @param ricette : array di ricette trovate
 * @param n_ricette
 * @param file_ricette
 */
void ricerca_ricettaSottstr(char *nome, t_ricetta ricette[], int* n_ricette, FILE *file_ricette);



/**
 * @fn t_ricetta richiediRicetta(int*)
 * @brief chiede all'utente di inserire un nome di ricetta e resituisce la ricetta voluta trovata nel file ricette
 * @param flag_home viene impostato ad 1 se l'utente inserisci la costante BACK_HOME altrimenti 0
 * @return ricetta desiderata
 */
t_ricetta richiediRicetta(int* flag_home);


/**
 * @fn void print_ricette(int, char*)
 * @brief visualizza a schermo tutte le ricette (in ordine alfabetico se ordina_file=1) presenti in filename_ricette
 * @param ordina_file
 * @param filename_ricette
 */
void print_ricette(int ordina_file, char* filename_ricette);


/**
 * @fn void caricaRicette()
 * @brief permette all'utente di aggiungere delle ricette al file ricette
 * 		  chiede all'utente di inserire una ricetta o più ricette con i relativi campi e la aggiunge in coda al file ricette
 * 		  - non permette l'aggiunta di una ricetta con lo stesso di nome di un altra già presente in file ricette
 * @post file ricette con l'aggiunta delle nuove ricette inserite
 */
void caricaRicette();



/**
 * @fn t_ricetta modificaRicetta(t_ricetta, int*)
 * @brief permette all'utente di modificare i campi di una ricetta passata come argomento
 * 		  - durante la modifica non permette all'utente di cambiare il nome con un altro di una ricetta già presente in file ricette
 * 		    e tiene in considerazione che deve essere presente sempre almeno un ingrediente
 * 		  - durante le molteplici richieste di input considera sempre il caso che l'utente possa inserire valori errati
 * 		    o che possa inserire la costante BACK_HOME ed in quest'ultimo caso imposta *flag_home a 1 e termina la funzione
 * @param ricetta
 * @param flag_home
 * @return ricetta modificata
 */
t_ricetta modificaRicetta(t_ricetta ricetta, int* flag_home);


/**
 * @fn void sovrascrivi_ricetta(char*, t_ricetta)
 * @brief sovrascrive nel file ricetta la ricetta con nome nome_ricetta con ricetta_modificata
 * 	      - cerca nel file ricette la ricetta con nome_ricetta e la sovrascrive con ricetta_modificata
 * @post  file ricette con la ricetta_modificata
 * @param nome_ricetta
 * @param ricetta_modificata
 */
void sovrascrivi_ricetta(char* nome_ricetta, t_ricetta ricetta_modificata);



/**
 * @fn int isAlimento_compatibile(t_alimento, t_alimento, int)
 * @brief determina se alimento1 è compatibile con alimento2
 *		  - controlla se alimento1 e alimento hanno stesso nome e stessa unita di misura
 *		  - se ignora_quantita==0 controlla anche che la quantità di alimento1 sia <= di alimento2
 *		 	altrimenti non esegue questa condizione
 * @param alimento1
 * @param alimento2
 * @param ignora_quantita (se ignora_quantita=1 ignora il controlla sulla quantità)
 * @return se tutti le condizioni sono vere ritorna 1 altrimenti 0
 */
int isAlimento_compatibile(t_alimento alimento1, t_alimento alimento2, int ignora_quantita);

/**
 * @fn int isPreparabile(t_ricetta, char*)
 * @brief determina se una ricetta è preparabile con gli alimenti presenti in filename_alimenti
 * 		  - per ogni ingrediente della ricetta verifica che sia presente nel frigo e che sia nelle quantita giuste
 * 		  - tutti gli ingredienti della ricetta con campo dispensa=1 vengono considerati come disponibili
 * @param ricetta
 * @param filename_alimenti
 * @return se tutti le condizioni sono vere ritorna 1 altrimenti 0
 */
int isPreparabile(t_ricetta ricetta, char* filename_alimenti );


/**
 * @fn int isContained(t_alimento[], t_alimento[], int, int)
 * @brief determina se un array di alimenti è contenuto in un altro array di alimenti
 *	      - verifica per ogni alimento in alimenti1[] sia presente presente un alimento in alimenti2[] con lo stesso nome e unita di misura
 * @param alimenti1
 * @param alimenti2
 * @param n_alimenti1
 * @param n_alimenti2
 * @return 1 se la condizione è verificata altrimenti 0
 */
int isContained(t_alimento alimenti1[], t_alimento alimenti2[], int n_alimenti1, int n_alimenti2);

/**
 * @fn void ricettePreparabili(t_ricetta[], int*, char*)
 * @brief resituisce tutte le ricette di filename_ricette preparabili con gli alimenti presenti nel file alimenti
 *		  per ogni ricetta in filename_ricette verifica se è preparabile e la aggiunge all'array ricette_preparabili[]
 * @pre ricette_preparabili[] vuoto, *n_ricette_preparabili di qualunque valore
 * @post ricette_preparabili[] riempito con le ricette preparabili, e con n_ricette_preparabili >= 0
 * @param ricette_preparabili
 * @param n_ricette_preparabili
 * @param filename_ricette
 */
void ricettePreparabili( t_ricetta ricette_preparabili[], int* n_ricette_preparabili, char* filename_ricette);


/**
 * @fn void ricetteCompatibili(t_alimento[], int, t_ricetta[], int*, char*)
 * @brief restituisce tutte le ricette di filename_ricette che sono preparabili e che contengono tra i loro ingredienti tutti gli alimenti di alimenti[]
 * 	      per ogni ricetta in filename_ricette verifica se è compatibile e la aggiunge all'array ricette_compatibili[]
 * @pre ricette_compatibili[] vuoto, *n_ricette_compatibili di qualunque valore
 * @post ricette_preparabili[] riempito con le ricette compatibili, e con n_ricette_comatibili >= 0
 * @param alimenti
 * @param n_alimenti
 * @param ricette_compatibili
 * @param n_ricette_compatibili
 * @param filename_ricette
 */
void ricetteCompatibili( t_alimento alimenti[], int n_alimenti, t_ricetta ricette_compatibili[], int* n_ricette_compatibili, char* filename_ricette);


/**
 * @fn void ordina_arrRicette_4giorni(t_ricetta[], int)
 * @brief ordina ricette[], in ordine decrescente, per il campo counter_giorni
 * @pre ricette non ordinato
 * @post ricette ordinato
 * @param ricette
 * @param n_ricette
 */
void ordina_arrRicette_4giorni(t_ricetta ricette[], int n_ricette);


/**
 * @fn void shift_arrRicette_4cat(t_ricetta[], int, t_categoria)
 * @brief imposta nelle prime posizioni le ricette con la categoria cat e "shifta" tutte le altre ricette mantenendo il loro ordine
 *
 * @pre ricette di ricette[] con la categoria cat in qualsiasi posizione
 * 		(ricette[] può anche non contenere nessuna ricetta con categoria cat, in tal caso ricette[] rimarrà invariato)
 * @post ricette di ricette[] con la categoria cat tutte nelle prime posizioni (se presenti)
 * @param ricette
 * @param n_ricette
 * @param cat (categoria per cui si vuole "shiftare" l'array ricette[])
 */
void shift_arrRicette_4cat(t_ricetta ricette[], int n_ricette, t_categoria cat);


/**
 * @fn void prioritarizza_ricette(t_ricetta[], int)
 * @brief ordina ricette in base alla categoria associata al giorno corrente e in base al counter_giorni di ogni ricetta
 * @pre  ricette di ricette[] non ordinate in base a counter_giorni e categoria giorno corrente
 * @post - ricette[] ordinato in modo tale che si trovino nelle prime posizioni le ricette la cui categoria è la stessa di quella associata al giorno corrente nel piano settimanale
 * 		    e queste ricette saranno ordinate in ordine decrescente secondo il campo counter_giorni
 * 		  - le restanti ricette saranno comunque ordinate in ordine decrescente secondo il campo counter_giorni
 * @param ricette
 * @param n_ricette
 */
void prioritarizza_ricette( t_ricetta ricette[], int n_ricette );

/**
 * @fn void consigliaRicette()
 * @brief consiglia all'utente che ricetta preparare e gli permette di prepararla
 * 		  - propone all'utente le ricette preparabili ordinate con prioritarizza_ricette(t_ricetta[], int)
 * 	      - l'utente in fase iniziale può anche decidere di inserire degli alimenti che dovranno necessariamente essere presenti tra gli ingredienti delle ricette proposte
 * 	      - se sono presenti ricette che rispecchiano queste caratterstiche viene permesso all'utente di prepararle e di inserire una valutazione
 * @post  ha li stessi effetti di preparaRicetta(t_ricetta) e valutaRicetta(char*, int*), in caso l'utente scelga di preparare e valutare la ricetta
 */
void consigliaRicette();

/**
 * @fn void preparaRicetta(t_ricetta)
 * @brief "prepara" la ricetta
 * @post - incrementa di uno il giorno corrente
 * 		 - riduce dal file alimenti la quantità per ogni ingrediente di ricetta.ingredienti[]
 * 		   nel caso in cui la quantità dell'alimento del file alimenti aggiornato sia 0 l'alimento verrà rimosso dal file
 * 		 - incrementa di uno il counter_giorni per ogni ricetta presente nel file ricette
 * 		   eccetto per quella che viene preparata il, cui counter_giorno è posto uguale a 0
 * 		 - aggiunge la ricetta preparata in ultima posizione del file cronologia ricette
 * @param ricetta
 */
void preparaRicetta(t_ricetta ricetta);



/**
 * @fn void valutaRicetta(char*, int*)
 * @brief permette all'utente di inserire una valutazione per la ricetta nel file ricette il cui nome corrisponte al nome passato per parametro
 * @post ricetta nel file ricette il cui nome corrisponte al nome passato per parametro con la valutazione inserita dall'utente
 * @param nome_ricetta
 * @param flag_home
 */
void valutaRicetta(char* nome_ricetta, int* flag_home);


/**
 * @fn void printStatistica_voti()
 * @brief mostra a schermo l'istogramma delle valutazioni ricette
 * 		  - l'istogramma mostra quante ricette hanno avuto una valutazione pari a 1,2,3,4,5
 * 		    e il numero di ricette non valutate
 * @post   stampa a schermo dell'istogramma
 */
void printStatistica_voti();





#endif /* GESTIONE_RICETTE_H_ */
